package ab.async.tester.controllers

import controllers.BaseControllerSpec
import ab.async.tester.service.execution.ExecutionsService
import ab.async.tester.controllers.auth.{
  AuthorizedAction,
  AuthenticatedAction,
  AuthenticatedRequest
}
import ab.async.tester.domain.execution.Execution
import ab.async.tester.domain.common.PaginatedResponse
import ab.async.tester.domain.user.{AuthenticatedUser, UserRole}
import play.api.test.Helpers._
import play.api.test.{FakeRequest, Helpers}
import play.api.libs.json.Json
import play.api.mvc._
import scala.concurrent.{Future, ExecutionContext}
import org.mockito.ArgumentMatchers.any
import io.circe.generic.auto._
import io.circe.syntax._

import utils.StubAuthorizedAction

class ExecutionControllerSpec extends BaseControllerSpec {

  val mockExecutionService = mock[ExecutionsService]

  val testUser = AuthenticatedUser(
    "user1",
    "user@example.com",
    Some("User"),
    UserRole.User,
    false
  )
  val stubAuthorizedAction = new StubAuthorizedAction(testUser)

  val cc = Helpers.stubControllerComponents()
  val controller =
    new ExecutionController(cc, mockExecutionService, stubAuthorizedAction)

  "ExecutionController" should {
    "getExecution should return execution" in {
      val execution =
        Execution("exec1", "flow1", "running", 0L, 0L, "user1", "org1", "team1")
      when(mockExecutionService.getExecutionById("exec1"))
        .thenReturn(Future.successful(Some(execution)))

      val request = FakeRequest(GET, "/api/v1/executions/exec1")
      val result = controller.getExecution("exec1").apply(request)

      status(result) mustBe OK
      contentAsJson(result) mustBe Json.parse(execution.asJson.noSpaces)
    }

    "getExecutions should return paginated executions" in {
      val executions = List(
        Execution("exec1", "flow1", "running", 0L, 0L, "user1", "org1", "team1")
      )
      val response = PaginatedResponse(executions, 1, 10, 0)

      when(mockExecutionService.getExecutions(any[Int], any[Int], anyOption))
        .thenReturn(Future.successful(response))

      val request = FakeRequest(GET, "/api/v1/executions")
      val result = controller.getExecutions().apply(request)

      status(result) mustBe OK
      contentAsJson(result) mustBe Json.parse(response.asJson.noSpaces)
    }
  }
}
