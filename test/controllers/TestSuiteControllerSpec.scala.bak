package ab.async.tester.controllers

import controllers.BaseControllerSpec
import ab.async.tester.service.testsuite.TestSuiteService
import ab.async.tester.controllers.auth.{
  AuthorizedAction,
  AuthenticatedAction,
  AuthenticatedRequest
}
import ab.async.tester.domain.testsuite.TestSuite
import ab.async.tester.domain.common.PaginatedResponse
import ab.async.tester.domain.execution.TestSuiteExecution
import ab.async.tester.domain.user.{AuthenticatedUser, UserRole}
import ab.async.tester.domain.requests.RunTestSuiteRequest
import play.api.test.Helpers._
import play.api.test.{FakeRequest, Helpers}
import play.api.libs.json.Json
import play.api.mvc._
import scala.concurrent.{Future, ExecutionContext}
import org.mockito.ArgumentMatchers.any
import io.circe.generic.auto._
import io.circe.syntax._

import utils.StubAuthorizedAction

class TestSuiteControllerSpec extends BaseControllerSpec {

  val mockTestSuiteService = mock[TestSuiteService]

  val testUser = AuthenticatedUser(
    "user1",
    "user@example.com",
    Some("User"),
    UserRole.User,
    false
  )
  val stubAuthorizedAction = new StubAuthorizedAction(testUser)

  val cc = Helpers.stubControllerComponents()
  val controller =
    new TestSuiteController(cc, mockTestSuiteService, stubAuthorizedAction)

  "TestSuiteController" should {
    "getTestSuites should return test suites" in {
      val suites = List(
        TestSuite(
          Some("1"),
          "test suite",
          "description",
          List.empty,
          true,
          0L,
          0L,
          "user1",
          "org1",
          "team1"
        )
      )
      val response = PaginatedResponse(suites, 1, 10, 0)

      when(
        mockTestSuiteService.getTestSuites(
          any,
          any,
          any,
          any,
          any,
          any[Int],
          any[Int]
        )
      )
        .thenReturn(Future.successful(response))

      val request = FakeRequest(GET, "/api/v1/test-suites")
      val result = controller.getTestSuites.apply(request)

      status(result) mustBe OK
      contentAsJson(result) mustBe Json.parse(response.asJson.noSpaces)
    }

    "getTestSuite should return a test suite" in {
      val suite = TestSuite(
        Some("1"),
        "test suite",
        "description",
        List.empty,
        true,
        0L,
        0L,
        "user1",
        "org1",
        "team1"
      )
      when(mockTestSuiteService.getTestSuite("1"))
        .thenReturn(Future.successful(Some(suite)))

      val request = FakeRequest(GET, "/api/v1/test-suites/1")
      val result = controller.getTestSuite("1").apply(request)

      status(result) mustBe OK
      contentAsJson(result) mustBe Json.parse(suite.asJson.noSpaces)
    }

    "createTestSuite should create a test suite" in {
      val suite = TestSuite(
        Some("1"),
        "new suite",
        "desc",
        List.empty,
        true,
        0L,
        0L,
        "user1",
        "org1",
        "team1"
      )
      when(mockTestSuiteService.createTestSuite(any[TestSuite]))
        .thenReturn(Future.successful(suite))

      val request = FakeRequest(POST, "/api/v1/test-suites")
        .withJsonBody(Json.parse(suite.asJson.noSpaces))

      val result = controller.createTestSuite().apply(request)

      status(result) mustBe CREATED
    }

    "runTestSuite should create execution" in {
      val runRequest = RunTestSuiteRequest("suite1", None, Map.empty)
      val execution = TestSuiteExecution(
        "exec1",
        "suite1",
        "pending",
        0,
        0,
        0,
        0L,
        0L,
        "user1",
        "org1",
        "team1"
      )

      when(mockTestSuiteService.triggerTestSuite(any[RunTestSuiteRequest]))
        .thenReturn(Future.successful(execution))

      val request = FakeRequest(POST, "/api/v1/test-suites/run")
        .withJsonBody(Json.parse(runRequest.asJson.noSpaces))

      val result = controller.runTestSuite().apply(request)

      status(result) mustBe CREATED
    }
  }
}
